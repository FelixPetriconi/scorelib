//
// Programmer:    Craig Stuart Sapp <craig@ccrma.stanford.edu>
// Creation Date: Thu Mar 13 23:50:19 PDT 2014
// Last Modified: Fri Jul 18 13:28:35 PDT 2014
// Filename:      ScorePage_tuplet.cpp
// URL:           https://github.com/craigsapp/scorelib/blob/master/src-library/ScorePage_tuplet.cpp
// Syntax:        C++11
//
// Description:   This file contains ScorePage class functions related to
//                tuplet analysis.
//

#include "ScorePage.h"

using namespace std;


//////////////////////////////
//
// ScorePage::analyzeTuplets -- Determine if notes/rests are linked into
//     tuplet groups.
//

void ScorePage::analyzeTuplets(SCORE_FLOAT tolerance) {
   if (!analysis_info.beamsIsValid()) {
      analyzeBeams();
   }
   analysis_info.invalidate("tuplets");

   int i;
   int maxstaff = getMaxStaff();
   for (i=1; i<=maxstaff; i++) {
      analyzeTupletsOnStaff(i, tolerance);
   }

   analysis_info.validate("tuplets");
}


//////////////////////////////
//
// ScorePage::tupletInfo -- Given a ScoreItem pointer to a note/rest or tuplet,
//    this function returns a TupletGroup pointer if the input
//    item belongs to a tuplet group.  Will return NULL if the
//    item is not part of a tuplet group.
//

TupletGroup* ScorePage::tupletInfo(ScoreItem* item) {
//   if (!analysis_info.tupletsIsValid()) {
//      analyzeTuplets();
//   }
   return tuplet_database.tupletInfo(item);
}



//////////////////////////////
//
// ScorePage::printTupletDatabase -- Print a list of the tuplet groups that
//    are generated by ScorePage::analyzeTuplets().
//

ostream& ScorePage::printTupletDatabase(ostream& out) {
   int size = tuplet_database.size();
   out << "# TUPLET DATABASE (" << size;
   if (size == 1) { out << " entry):"   << endl; }
   else           { out << " entries):" << endl; }
   tuplet_database.printDatabase(out);
   return out;
}



///////////////////////////////////////////////////////////////////////////
//
// Protected functions:
//

//////////////////////////////
//
// ScorePage::analyzeTupletsOnStaff --
//

void ScorePage::analyzeTupletsOnStaff(int p2index, SCORE_FLOAT tolerance) {
   if (!analysis_info.beamsIsValid()) {
      analyzeBeams();
   }
   vectorSIp& items = itemlist_staffsorted[p2index];

   int tupletQ = 0;
   int i;
   SCORE_FLOAT p3;
   SCORE_FLOAT tp3;
   SCORE_FLOAT p6;
   ScoreItem* item;
   for (i=0; i<items.size(); i++) {
      item = items[i];
      if (item->isTupletBeam()) {
         tupletQ = 1;
      } else if (item->isTupletBracket()) {
         tupletQ = 1;
      }
      if (tupletQ == 0) {
         continue;
      }
      tupletQ = 0;

      // If the beam is has a tuplet marking on it, presume that all
      // notes in the beam group are to be placed in the tuplet group
      // (This is not always true).
      if (item->isTupletBeam()) {
         BeamGroup* bi = beam_database.beamInfo(item);
         for (auto& item2 : bi->notes) {
            tuplet_database.linkItems(item, item2);
         }
      } else if (item->isTupletBracket()) {
         // The tuplet notes are grouped by a slur bracket.
         // Iterate through all notes within the bracket
         // and group them with this bracket.  Currently
         // not keeping track of layers, so will need to be
         // generalized better.  Should also check to see of the
         // slur is slightly inside of the notes it groups (currently
         // will be dropped if outside of P3/P6 range of slur, even if
         // close.
         p3 = item->getHPos();
         p6 = item->getHPosRight();
         int starti = i;

         // backtrack on staff to first item at given P3.
         int j;
         for (j=i; j>=0; j--) {
            if (items[j]->getHPos() >= p3-tolerance) {
               break;
            }
            starti = j;
         }
         for (j=starti; j<items.size(); j++) {
            if (!items[j]->isNoteOrRestItem()) {
               continue;
            }
            tp3 = items[j]->getHPos();
            if ((tp3 >= p3-tolerance) && (tp3 <= p6+tolerance)) {
               // need to filter for layer here...
               tuplet_database.linkItems(item, items[j]);
            }
         }
      }
   }
}



