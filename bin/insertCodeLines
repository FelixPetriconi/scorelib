#!/usr/bin/perl
#
# Programmer:    Craig Stuart Sapp <craig.stanford.edu>
# Creation Date: Sun Feb  8 20:56:03 PST 2015
# Last Modified: Sun Feb  8 20:56:03 PST 2015
# Filename:      /tmp/scorelib/class/ScoreUtility/insertCodeLines
# Syntax:        perl 5
# vim:           ts=3 expandtab hlsearch
#
# Description:   Calculate code lines for functions in scorelib src files.
#                and insert the range within the ATON documentation for the
#                function so that it can be highlighted in the scorelib
#                documentation.
#

use strict;

my %SrcContents;
my @files = @ARGV;
my $urlbase = "https://raw.githubusercontent.com/craigsapp/scorelib/master/src-library";

foreach my $file (@files) {
   processFile($file);
}



##############################
##
## processFile -- Read an ATON file and insert the source code line range
##    for the given function in the ATON file (only one function allowed
##    in each ATON file with this code).
##

sub processFile {
   my ($file) = @_;
   open (FILE, $file) or die "Cannot read $file.";
   my @contents = <FILE>;
   close FILE;
   my $function = getFunctionName($file, @contents);
print "FUNCTION = $function\n";
   my @src = getSourceContents($file, @contents);
   my $linerange = getSourceLines($file, $function, @src);
   print "$function: $linerange\n";
}



##############################
##
## getSourceLines --
##

sub getSourceLines {
   my ($file, $function, @src) = @_;
   my $startline = -1;
   my $endline = -1;
   my $i;
   my $line;
   my $fname;
   my $tline = -1;
   for ($i=0; $i<@src; $i++) {
      $line = $src[$i];
      if ($line =~ /^\/{20}/) {
         $tline = $1;
      } elsif ($line !~ /^\//) {
         $tline = -1;
      }
      if ($line =~ /^\/\/\s*[^:]+::([^\s]+)\s*--/) {
         $fname = $1;
print "FNAME = $fname and FUNCTION eq $function\n";
         if ($fname eq $function) {
            $startline = $i;
            last;
         }
      }
   }
   if ($startline <= 0) {
      die "Could not find function '$function' in $file. startline = $startline\n";
   }

   $endline = $startline;
   for ($i=$startline+1; $i<@src; $i++) {
      $line = $src[$i];
      if ($line =~ /^\s*$/) {
         next;
      }
      if ($line =~ /^\/\/\s*[^:]+::([^\s]+)\s*--/) {
         last;
      }
      if ($line =~ /^\//) {
         next;
      }
      $endline = $i;
   }
   if ($endline <= $startline) {
      die "Could not find end line in $file for function $function.\n";
   }

   $startline++;
   $endline++;
   return "$startline-$endline";
}



##############################
##
## getSourceContents --
##     @FILE:		ScoreUtility_math.cpp
##

sub getSourceContents {
   my ($file, @contents) = @_;
   my $srcname;
   foreach my $line (@contents) {
      if ($line =~ /^\@FILE\s*:\s*([^\s]+)\s*$/) {
         $srcname = $1;
print "FILENAME = $srcname\n";
         if ($SrcContents{$srcname} !~ /^\s*$/) {
            return split(/\n/, $SrcContents{$srcname});
         } else {
            $SrcContents{$srcname} = `wget "$urlbase/$srcname" -O -`;
print "DOWNLOADED $SrcContents{$srcname}\n\n";
            return split(/\n/, $SrcContents{$srcname});
         }
      }
   }
   die "Cannot find source code filename in $file.\n";
}



##############################
##
## getFunctionName --
##

sub getFunctionName {
   my ($file, @contents) = @_;
   foreach my $line (@contents) {
      if ($line =~ /^\@METHOD\s*:\s*([^\s]+)\s*$/) {
         return $1;
      }
   }
   die "Cannot find function name in $file.\n";
}



